(ns com.blockether.svar.rlm.pageindex-test
  "Tests for the PageIndex PDF processing module.
   
   Uses example.pdf from resources-test as the test fixture.
   The PDF has:
   - 1 page
   - Author: Vb1
   - Created with Acrobat PDFMaker 11 for Word
   - Created: 2014-10-22T12:29:10Z"
  (:require
   [babashka.fs :as fs]
   [clojure.java.io :as io]
   [clojure.spec.alpha :as s]
   [lazytest.core :refer [defdescribe describe expect it throws?]]
   [com.blockether.svar.rlm.internal.pageindex.pdf :as pdf]
   [com.blockether.svar.rlm.internal.pageindex.core :as pageindex]
   [com.blockether.svar.rlm.internal.pageindex.spec :as pageindex-spec]
   [com.blockether.svar.rlm.internal.pageindex.vision :as vision])
  (:import
   [java.awt.image BufferedImage]))

;; =============================================================================
;; Test Constants
;; =============================================================================

(def ^:private TEST_PDF_PATH
  "Path to the test PDF file."
  "resources-test/example.pdf")

(def ^:private TEST_FIXTURE_PATH
  "Path to the expected index fixture Nippy file."
  "resources-test/example-index.nippy")

;; =============================================================================
;; Fixture: Expected Index for example.pdf
;; =============================================================================

(def ^:private EXAMPLE_PDF_FIXTURE
  "Expected structure from indexing example.pdf.
   
   This fixture represents what a pageindex should produce:
   - :document/name - 'example' (filename without extension)
   - :document/extension - 'pdf'
   - :document/pages - vector with 1 page
   - :document/toc - vector of TOC entries (may be empty if no TOC in doc)
   - :document/author - 'Vb1' (from PDF metadata)
   - :document/created-at - 2014-10-22T12:29:10Z
   - :document/updated-at - 2014-10-22T12:29:11Z
   
   The :document/pages structure contains:
   - :page/index - 0-based page number
   - :page/nodes - vector of content nodes in reading order
   
   Each node has:
   - :page.node/type - :section, :heading, :paragraph, :image, :table, etc.
   - :page.node/id - unique string ID within the page
   - :page.node/parent-id - parent node ID (nil for root)
   - :page.node/content - text content
   - :page.node/description - AI-generated description (for sections)
   - :page.node/level - h1-h6 for headings, paragraph/citation for paragraphs"
  {:document/name "example"
   :document/extension "pdf"
   :document/author "Vb1"
   :document/title nil ;; May be inferred by LLM
   :document/abstract nil ;; May be generated by LLM
   :document/pages [{:page/index 0
                     :page/nodes []}] ;; Nodes filled by LLM extraction
   :document/toc []}) ;; TOC entries (if present in document)

;; =============================================================================
;; PDF Module Tests (No LLM Required)
;; =============================================================================

(defdescribe pdf-module-test
  (describe "page-count"
            (it "returns correct page count for example.pdf"
                (expect (= 1 (pdf/page-count TEST_PDF_PATH))))

            (it "throws for non-existent file"
                (expect (throws? clojure.lang.ExceptionInfo
                                 #(pdf/page-count "non-existent.pdf")))))

  (describe "pdf-metadata"
            (it "extracts author from example.pdf"
                (let [meta (pdf/pdf-metadata TEST_PDF_PATH)]
                  (expect (= "Vb1" (:author meta)))))

            (it "extracts creator application"
                (let [meta (pdf/pdf-metadata TEST_PDF_PATH)]
                  (expect (= "Acrobat PDFMaker 11 fÃ¼r Word" (:creator meta)))))

            (it "extracts producer"
                (let [meta (pdf/pdf-metadata TEST_PDF_PATH)]
                  (expect (= "Adobe PDF Library 11.0" (:producer meta)))))

            (it "extracts creation date"
                (let [meta (pdf/pdf-metadata TEST_PDF_PATH)]
                  (expect (some? (:created-at meta)))
                  (expect (inst? (:created-at meta)))))

            (it "extracts modification date"
                (let [meta (pdf/pdf-metadata TEST_PDF_PATH)]
                  (expect (some? (:updated-at meta)))
                  (expect (inst? (:updated-at meta)))))

            (it "throws for non-existent file"
                (expect (throws? clojure.lang.ExceptionInfo
                                 #(pdf/pdf-metadata "non-existent.pdf")))))

  (describe "pdf->images"
            (it "returns vector of BufferedImage"
                (let [images (pdf/pdf->images TEST_PDF_PATH)]
                  (expect (vector? images))
                  (expect (= 1 (count images)))
                  (expect (instance? BufferedImage (first images)))))

            (it "renders at default DPI (150)"
                (let [images (pdf/pdf->images TEST_PDF_PATH)
                      img (first images)]
        ;; At 150 DPI, a typical A4 page (~8.27x11.69 inches) renders to ~1240x1754 pixels
        ;; Allow some tolerance for different PDF page sizes
                  (expect (> (.getWidth img) 500))
                  (expect (> (.getHeight img) 500))))

            (it "renders at custom DPI"
                (let [images-150 (pdf/pdf->images TEST_PDF_PATH {:dpi 150})
                      images-300 (pdf/pdf->images TEST_PDF_PATH {:dpi 300})
                      img-150 (first images-150)
                      img-300 (first images-300)]
        ;; 300 DPI should be ~2x larger than 150 DPI
                  (expect (> (.getWidth img-300) (* 1.5 (.getWidth img-150))))
                  (expect (> (.getHeight img-300) (* 1.5 (.getHeight img-150))))))

            (it "throws for non-existent file"
                (expect (throws? clojure.lang.ExceptionInfo
                                 #(pdf/pdf->images "non-existent.pdf"))))))

;; =============================================================================
;; Spec Validation Tests (No LLM Required)
;; =============================================================================

(defdescribe spec-validation-test
  (describe "document structure validation"
            (it "validates minimal valid document"
                (let [doc {:document/name "test"
                           :document/extension "pdf"
                           :document/pages [{:page/index 0
                                             :page/nodes []}]
                           :document/toc []}]
                  (expect (pageindex-spec/valid-document? doc))))

            (it "rejects document without name"
                (let [doc {:document/extension "pdf"
                           :document/pages []
                           :document/toc []}]
                  (expect (not (pageindex-spec/valid-document? doc)))))

            (it "rejects document without extension"
                (let [doc {:document/name "test"
                           :document/pages []
                           :document/toc []}]
                  (expect (not (pageindex-spec/valid-document? doc)))))

            (it "validates document with optional fields"
                (let [doc {:document/name "test"
                           :document/title "Test Document"
                           :document/abstract "This is a test."
                           :document/extension "pdf"
                           :document/author "Test Author"
                           :document/pages [{:page/index 0
                                             :page/nodes []}]
                           :document/toc []
                           :document/created-at (java.time.Instant/now)
                           :document/updated-at (java.time.Instant/now)}]
                  (expect (pageindex-spec/valid-document? doc)))))

  (describe "page structure validation"
            (it "validates page with nodes"
                (let [page {:page/index 0
                            :page/nodes [{:page.node/type :paragraph
                                          :page.node/id "1"
                                          :page.node/content "Test content"}]}]
                  (expect (s/valid? ::pageindex-spec/page page))))

            (it "validates page with section and heading"
                (let [page {:page/index 0
                            :page/nodes [{:page.node/type :section
                                          :page.node/id "1"
                                          :page.node/description "A test section"}
                                         {:page.node/type :heading
                                          :page.node/id "2"
                                          :page.node/parent-id "1"
                                          :page.node/level "h1"
                                          :page.node/content "Test Heading"}]}]
                  (expect (s/valid? ::pageindex-spec/page page)))))

  (describe "TOC entry validation"
            (it "validates complete TOC entry"
                (let [entry {:document.toc/type :toc-entry
                             :document.toc/id "uuid-string"
                             :document.toc/title "Chapter 1"
                             :document.toc/target-page 0
                             :document.toc/target-section-id "section-uuid"
                             :document.toc/level "l1"}]
                  (expect (s/valid? ::pageindex-spec/toc-entry entry))))

            (it "validates TOC entry with optional fields"
                (let [entry {:document.toc/type :toc-entry
                             :document.toc/id "uuid-string"
                             :document.toc/parent-id "parent-uuid"
                             :document.toc/title "Section 1.1"
                             :document.toc/description "An introduction to the topic"
                             :document.toc/target-page 5
                             :document.toc/target-section-id "section-uuid"
                             :document.toc/level "l2"}]
                  (expect (s/valid? ::pageindex-spec/toc-entry entry))))))

;; =============================================================================
;; Fixture Structure Tests (expected index shape)
;; =============================================================================

(defdescribe fixture-structure-test
  (describe "EXAMPLE_PDF_FIXTURE"
            (it "has required document fields"
                (expect (= "example" (:document/name EXAMPLE_PDF_FIXTURE)))
                (expect (= "pdf" (:document/extension EXAMPLE_PDF_FIXTURE)))
                (expect (= "Vb1" (:document/author EXAMPLE_PDF_FIXTURE))))

            (it "has pages vector"
                (expect (vector? (:document/pages EXAMPLE_PDF_FIXTURE)))
                (expect (= 1 (count (:document/pages EXAMPLE_PDF_FIXTURE)))))

            (it "has page with correct index"
                (let [page (first (:document/pages EXAMPLE_PDF_FIXTURE))]
                  (expect (= 0 (:page/index page)))
                  (expect (vector? (:page/nodes page)))))

            (it "has TOC vector"
                (expect (vector? (:document/toc EXAMPLE_PDF_FIXTURE))))))

;; =============================================================================
;; Core API Tests (No LLM - file detection only)
;; =============================================================================

(defdescribe core-api-test
  (describe "file type detection"
            (it "detects PDF files exist"
                (expect (.exists (io/file TEST_PDF_PATH))))

            (it "throws for non-existent file"
      ;; Test via the build-index error path - file exists check
                (expect (throws? clojure.lang.ExceptionInfo
                                 #(pageindex/build-index "non-existent.pdf"))))))

;; =============================================================================
;; Integration Tests (Requires LLM - marked for conditional execution)
;; =============================================================================

(def ^:private integration-config
  "LLM config for integration tests."
  {:api-key (or (System/getenv "OPENAI_API_KEY")
                (System/getenv "BLOCKETHER_LLM_API_KEY"))
   :base-url (or (System/getenv "OPENAI_BASE_URL")
                 (System/getenv "BLOCKETHER_LLM_API_BASE_URL")
                 "https://api.openai.com/v1")})

(defn- integration-tests-enabled?
  "Returns true if LLM integration tests should run."
  []
  (some? (:api-key integration-config)))

(defdescribe build-index-integration-test
  (describe "build-index for example.pdf"
            (it "produces valid document structure (when LLM available)"
                (when (integration-tests-enabled?)
                  (let [doc (pageindex/build-index TEST_PDF_PATH
                                                   {:config integration-config})]
          ;; Check required fields
                    (expect (= "example" (:document/name doc)))
                    (expect (= "pdf" (:document/extension doc)))

          ;; Check pages
                    (expect (vector? (:document/pages doc)))
                    (expect (= 1 (count (:document/pages doc))))

          ;; Check page structure
                    (let [page (first (:document/pages doc))]
                      (expect (= 0 (:page/index page)))
                      (expect (vector? (:page/nodes page))))

          ;; Check TOC
                    (expect (vector? (:document/toc doc)))

          ;; Check metadata from PDF
                    (expect (= "Vb1" (:document/author doc)))
                    (expect (inst? (:document/created-at doc)))

          ;; Validate against spec
                    (expect (pageindex-spec/valid-document? doc)))))

            (it "index! saves and load-index reads back (when LLM available)"
                (when (integration-tests-enabled?)
                  (let [output-path "resources-test/example-generated.nippy"
                        result (pageindex/index! TEST_PDF_PATH
                                                 {:output output-path
                                                  :config integration-config})
                        loaded (pageindex/load-index output-path)]
                    (try
            ;; Check result structure
                      (expect (some? (:document result)))
                      (expect (= output-path (:output-path result)))

            ;; Check loaded matches original
                      (expect (= (:document/name (:document result))
                                 (:document/name loaded)))
                      (expect (= (:document/extension (:document result))
                                 (:document/extension loaded)))

            ;; Validate loaded document
                      (expect (pageindex-spec/valid-document? loaded))
                      (finally
              ;; Cleanup
                        (io/delete-file output-path true))))))))

;; =============================================================================
;; Fixture Loading Tests
;; =============================================================================

(defdescribe fixture-loading-test
  (describe "load saved index"
            (it "loads fixture Nippy when available"
                (when (.exists (io/file TEST_FIXTURE_PATH))
                  (let [doc (pageindex/load-index TEST_FIXTURE_PATH)]
                    (expect (= "example" (:document/name doc)))
                    (expect (pageindex-spec/valid-document? doc)))))))

;; =============================================================================
;; build-index Output Dir Tests (No LLM)
;; =============================================================================

(defdescribe build-index-output-dir-test
  (describe "build-index :path with output-dir"
            (it "writes PNG files for visual nodes"
                (let [output-dir (fs/create-temp-dir {:prefix "pageindex-output-"})
                      fake-pages [{:page/index 0
                                   :page/nodes [{:page.node/type :image
                                                 :page.node/id "img-1"
                                                 :page.node/image-data (byte-array [1 2 3])
                                                 :page.node/description "diagram"}]}]]
                  (try
                    (with-redefs [com.blockether.svar.rlm.internal.pageindex.core/extract-text (fn [_ _] fake-pages)
                                  com.blockether.svar.rlm.internal.pageindex.core/generate-document-abstract (fn [_ _] nil)
                                  vision/infer-document-title (fn [_ _] nil)]
                      (let [doc (pageindex/build-index TEST_PDF_PATH {:output-dir (str output-dir)})
                            node-id (get-in doc [:document/pages 0 :page/nodes 0 :page.node/id])
                            img-path (fs/path output-dir (str node-id ".png"))]
                        (expect (fs/exists? img-path))))
                    (finally
                      (fs/delete-tree output-dir)))))

            (it "throws when output-dir does not exist"
                (with-redefs [com.blockether.svar.rlm.internal.pageindex.core/extract-text (fn [_ _] [])
                              com.blockether.svar.rlm.internal.pageindex.core/generate-document-abstract (fn [_ _] nil)
                              vision/infer-document-title (fn [_ _] nil)]
                  (expect (throws? clojure.lang.ExceptionInfo
                                   #(pageindex/build-index TEST_PDF_PATH {:output-dir "does-not-exist"}))))))

  (describe "build-index :path without output-dir"
            (it "retains image bytes in returned structure"
                (let [fake-pages [{:page/index 0
                                   :page/nodes [{:page.node/type :image
                                                 :page.node/id "img-1"
                                                 :page.node/image-data (byte-array [9 9 9])
                                                 :page.node/description "diagram"}]}]]
                  (with-redefs [com.blockether.svar.rlm.internal.pageindex.core/extract-text (fn [_ _] fake-pages)
                                com.blockether.svar.rlm.internal.pageindex.core/generate-document-abstract (fn [_ _] nil)
                                vision/infer-document-title (fn [_ _] nil)]
                    (let [doc (pageindex/build-index TEST_PDF_PATH)
                          img-bytes (get-in doc [:document/pages 0 :page/nodes 0 :page.node/image-data])]
                      (expect (bytes? img-bytes)))))))

  (describe "build-index :string ignores output-dir"
            (it "does not fail when output-dir is set"
                (with-redefs [vision/extract-text-from-string
                              (fn [_ _] [{:page/index 0
                                          :page/nodes [{:page.node/type :paragraph
                                                        :page.node/id "p1"
                                                        :page.node/content "hello"}]}])
                              com.blockether.svar.rlm.internal.pageindex.core/generate-document-abstract (fn [_ _] nil)
                              vision/infer-document-title (fn [_ _] nil)]
                  (let [doc (pageindex/build-index "Hello" {:content-type :txt
                                                            :doc-name "sample"
                                                            :output-dir "missing"})]
                    (expect (= "sample" (:document/name doc))))))))

;; =============================================================================
;; Table ASCII Content Tests (No LLM)
;; =============================================================================

(defdescribe table-ascii-content-test
  (describe "table nodes with :page.node/content"
            (it "preserves ASCII table content through build-index pipeline"
                (let [ascii-table "| Name  | Age |\n|-------|-----|\n| Alice | 30  |\n| Bob   | 25  |"
                      fake-pages [{:page/index 0
                                   :page/nodes [{:page.node/type :section
                                                 :page.node/id "1"
                                                 :page.node/description "Data section"}
                                                {:page.node/type :heading
                                                 :page.node/id "2"
                                                 :page.node/parent-id "1"
                                                 :page.node/level "h1"
                                                 :page.node/content "Results"}
                                                {:page.node/type :table
                                                 :page.node/id "3"
                                                 :page.node/parent-id "1"
                                                 :page.node/kind "data"
                                                 :page.node/bbox [10 20 300 200]
                                                 :page.node/description "A table showing names and ages"
                                                 :page.node/content ascii-table}]}]]
                  (with-redefs [com.blockether.svar.rlm.internal.pageindex.core/extract-text (fn [_ _] fake-pages)
                                com.blockether.svar.rlm.internal.pageindex.core/generate-document-abstract (fn [_ _] nil)
                                vision/infer-document-title (fn [_ _] nil)]
                    (let [doc (pageindex/build-index TEST_PDF_PATH)
                          table-node (->> (get-in doc [:document/pages 0 :page/nodes])
                                          (filter #(= :table (:page.node/type %)))
                                          first)]
                      (expect (some? table-node))
                      (expect (= ascii-table (:page.node/content table-node)))
                      (expect (= "A table showing names and ages" (:page.node/description table-node)))))))

            (it "validates table node with content against spec"
                (let [table-node {:page.node/type :table
                                  :page.node/id "t1"
                                  :page.node/kind "data"
                                  :page.node/bbox [0 0 100 100]
                                  :page.node/description "Test table"
                                  :page.node/content "| A | B |\n|---|---|\n| 1 | 2 |"}]
                  (expect (s/valid? ::pageindex-spec/content-node table-node))))

            (it "validates table node without content against spec"
                (let [table-node {:page.node/type :table
                                  :page.node/id "t1"
                                  :page.node/kind "data"
                                  :page.node/bbox [0 0 100 100]
                                  :page.node/description "Test table"}]
                  (expect (s/valid? ::pageindex-spec/content-node table-node))))

            (it "table content survives ID translation"
                (let [ascii-table "| X | Y |\n|---|---|\n| 1 | 2 |"
                      pages [{:page/index 0
                              :page/nodes [{:page.node/type :table
                                            :page.node/id "1"
                                            :page.node/kind "data"
                                            :page.node/bbox [0 0 100 100]
                                            :page.node/description "Test"
                                            :page.node/content ascii-table}]}]
                      translated (pageindex/group-continuations
                                  (#'com.blockether.svar.rlm.internal.pageindex.core/translate-all-ids pages))
                      table-node (first (:page/nodes (first translated)))]
                  (expect (= ascii-table (:page.node/content table-node)))
                  ;; ID should be translated to UUID
                  (expect (not= "1" (:page.node/id table-node)))))))
