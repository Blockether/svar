(ns com.blockether.svar.internal.rlm.internal.pageindex.spec
  "Comprehensive clojure.spec definitions for RLM data structures.
   
   This namespace centralizes ALL specs for the RLM system to provide
   a clear view of the complete data model. Individual namespaces will require
   this namespace and use these specs for validation.
   
   Data Model Philosophy:
   - FLAT structure with parent references (Datalevin-style)
   - All keywords are namespaced (`:node/*`, `:page/*`, `:toc/*`)
   - Vector of maps output (not nested trees)
   - `:node/parent-id` creates hierarchy (nil for root nodes)"
  (:require
   [clojure.spec.alpha :as s]))

;;; ============================================================================
;;; Core Domain Specs
;;; ============================================================================

;; Node ID: UUID (java.util.UUID)
(s/def :node/id
  uuid?)

;; Parent ID: Either a node ID or nil (for root nodes)
(s/def :node/parent-id
  (s/nilable :node/id))

;; Node title: Non-empty string
(s/def :node/title
  (s/and string? seq))

;; Start index: First page of section (0-based, so page 1 = index 0)
(s/def :node/start-index
  nat-int?)

;; End index: Last page of section (0-based, so page 10 = index 9)
(s/def :node/end-index
  nat-int?)

;; Physical index: ACTUAL page in PDF where section title appears
;; (May differ from :toc/page due to TOC errors or page numbering schemes)
(s/def :node/physical-index
  nat-int?)

;; Node text content: String (can be empty)
(s/def :node/text
  string?)

;; Node summary: String (generated by LLM or copied from text if short)
(s/def :node/summary
  string?)

;; Node keywords: Vector of relevant keywords extracted from content
;; Example: ["machine learning" "neural networks" "deep learning"]
(s/def :node/keywords
  (s/coll-of string? :kind vector?))

;; Node abbreviations: Vector of abbreviation maps with expansion
;; Example: [{:abbreviation "ML" :expansion "Machine Learning"}]
(s/def :node.abbreviation/abbreviation
  (s/and string? seq))

(s/def :node.abbreviation/expansion
  (s/and string? seq))

(s/def ::abbreviation
  (s/keys :req [:node.abbreviation/abbreviation
                :node.abbreviation/expansion]))

(s/def :node/abbreviations
  (s/coll-of ::abbreviation :kind vector?))

;; Node images: Vector of extracted images with bounding box and base64 data
;; Bounding box is in pixels [xmin, ymin, xmax, ymax]
;; Example: [{:image/page 0 :image/description "Figure 1" :image/bbox [10 20 200 150] :image/data "base64..."}]
(s/def :image/page
  nat-int?)

(s/def :image/description
  string?)

(s/def :image/bbox
  (s/coll-of int? :kind vector? :count 4))

(s/def :image/data
  (s/nilable string?))  ; Base64-encoded PNG, can be nil if extraction failed

(s/def ::extracted-image
  (s/keys :req [:image/page
                :image/description
                :image/bbox]
          :opt [:image/data]))

(s/def :node/images
  (s/coll-of ::extracted-image :kind vector?))

;; Structure index: Hierarchical numbering ("1", "1.1", "1.2.3", etc.)
(s/def :node/structure
  (s/and string?
         #(re-matches #"\d+(\.\d+)*" %)))

;; TOC page: What the table of contents CLAIMS the page number is
;; (Often wrong! Example: TOC says "Chapter 1 ... 1" but it's actually on page 3)
;; Verification & fixing loops correct this to match :node/physical-index
(s/def :toc/page
  (s/nilable nat-int?))

;; Complete node specification
(s/def ::node
  (s/keys :req [:node/id
                :node/title
                :node/start-index
                :node/end-index]
          :opt [:node/parent-id
                :node/physical-index
                :node/text
                :node/summary
                :node/keywords
                :node/abbreviations
                :node/images
                :node/structure
                :toc/page]))

;; Flat structure: Vector of nodes
(s/def ::flat-structure
  (s/coll-of ::node :kind vector?))

;;; ============================================================================
;;; Page Extraction Specs (Node-Based Structure)
;;; ============================================================================

;; Page number (0-based)
(s/def :page/index
  nat-int?)

;; Document node types (keyword values: :section, :heading, :paragraph, etc.)
(s/def :page.node/type
  #{:section :heading :paragraph :list-item :image :table :header :footer :metadata})

;; Node unique identifier (string: "1", "2", "3", etc.)
(s/def :page.node/id
  string?)

;; Parent node ID (for hierarchy - null for top-level)
(s/def :page.node/parent-id
  (s/nilable string?))

;; Node levels (heading: h1-h6, paragraph: paragraph/citation/code/etc., list: l1-l6)
(s/def :page.node/level
  string?)

;; Node text content (text for text nodes)
(s/def :page.node/content
  string?)

;; Node image bytes (PNG)
(s/def :page.node/image-data
  bytes?)

;; Optional: AI-generated description (for sections, images, tables)
(s/def :page.node/description
  (s/nilable string?))

;; Optional: continuation from previous page
(s/def :page.node/continuation?
  boolean?)

;; Optional: caption text from document (for images/tables)
(s/def :page.node/caption
  (s/nilable string?))

;; Optional: kind of visual element (photo, diagram, chart, data, form, etc.)
(s/def :page.node/kind
  string?)

;; Optional: group ID for continuation grouping (shared UUID across pages)
(s/def :page.node/group-id
  string?)

;; Optional: bounding box for visual elements [xmin, ymin, xmax, ymax] in pixels
(s/def :page.node/bbox
  (s/coll-of int? :kind vector? :count 4))

;; Single content node within a page (namespaced keys)
;; Note: :page.node/content holds text for text nodes; visual nodes use :page.node/image-data (bytes)
(s/def ::content-node
  (s/keys :req [:page.node/type
                :page.node/id]
          :opt [:page.node/parent-id
                :page.node/level
                :page.node/content
                :page.node/image-data
                :page.node/description
                :page.node/continuation?
                :page.node/caption
                :page.node/kind
                :page.node/bbox
                :page.node/group-id]))

;; Page nodes: vector of content nodes in reading order
(s/def :page/nodes
  (s/coll-of ::content-node :kind vector?))

;; Page map (extraction result - node-based)
(s/def ::page
  (s/keys :req [:page/index
                :page/nodes]))

;; Page list (vector of pages)
(s/def ::page-list
  (s/coll-of ::page :kind vector?))

;;; ============================================================================
;;; TOC (Table of Contents) Detection Specs
;;; ============================================================================

;; TOC detection result: "yes" (TOC found) or "no" (no TOC)
;; Used to decide which of 3 processing paths to take
(s/def :toc/detected
  #{"yes" "no"})

;; TOC pages: Vector of page indices where TOC appears
;; Example: [0 1 2] means TOC spans pages 0, 1, and 2
(s/def ::toc-pages
  (s/coll-of nat-int? :kind vector?))

;; Has page numbers: Does the TOC include page numbers after section titles?
;; Example: "Chapter 1 ..... 5" (has page numbers)
;; vs:      "Chapter 1" (no page numbers)
;; Determines which TOC processing path to use
(s/def :toc/has-page-numbers
  boolean?)

;;; ============================================================================
;;; TOC Transformation Specs
;;; ============================================================================

;; Raw TOC item: LLM-extracted section from table of contents
;; Example: {:node/structure "1.2" :node/title "Background" :toc/page 5}
;; This is BEFORE tree building and verification
(s/def ::raw-toc-item
  (s/keys :req [:node/structure
                :node/title]
          :opt [:toc/page]))

;; Raw TOC: Vector of TOC items (flat, before processing)
;; This is the intermediate format after LLM extraction
(s/def ::raw-toc
  (s/coll-of ::raw-toc-item :kind vector?))

;;; ============================================================================
;;; Options & Configuration Specs
;;; ============================================================================

;; How many pages to check for TOC (default 20)
(s/def :options/toc-check-pages
  pos-int?)

;; Max tokens per chunk (default 20000)
(s/def :options/max-tokens-per-chunk
  pos-int?)

;; Max pages per node (default 10)
(s/def :options/max-pages-per-node
  pos-int?)

;; LLM model to use (default varies by function)
(s/def :options/model
  string?)

;; Complete options map
(s/def ::options
  (s/keys :opt [:options/toc-check-pages
                :options/max-tokens-per-chunk
                :options/max-pages-per-node
                :options/model]))

;;; ============================================================================
;;; Main API Specs
;;; ============================================================================

;; Document name (derived from filename)
(s/def :doc/name
  string?)

;; Complete build-index result
(s/def ::build-index-result
  (s/keys :req [:doc/name
                ::flat-structure]))

;;; ============================================================================
;;; Document Specs (RLM output)
;;; ============================================================================

;; Document name: filename without extension
(s/def :document/name
  (s/and string? seq))

;; Document title: extracted from metadata or first heading
(s/def :document/title
  (s/nilable string?))

;; Document abstract: LLM-generated summary from section descriptions
(s/def :document/abstract
  (s/nilable string?))

;; Document extension: file type (pdf, md, txt)
(s/def :document/extension
  (s/and string? #{"pdf" "md" "txt" "docx" "html"}))

;; Document pages: vector of extracted pages
(s/def :document/pages
  ::page-list)

;;; ============================================================================
;;; TOC Entry Specs (document.toc namespace)
;;; ============================================================================

;; TOC entry type
(s/def :document.toc/type
  #{:toc-entry})

;; TOC entry ID (UUID string)
(s/def :document.toc/id
  string?)

;; TOC entry parent ID (nil for root entries)
(s/def :document.toc/parent-id
  (s/nilable string?))

;; TOC entry title
(s/def :document.toc/title
  string?)

;; TOC entry description (optional, can be nil)
(s/def :document.toc/description
  (s/nilable string?))

;; TOC entry target page (0-based index)
(s/def :document.toc/target-page
  nat-int?)

;; TOC entry target section ID (UUID string linking to page node)
(s/def :document.toc/target-section-id
  string?)

;; TOC entry level (l1, l2, l3, etc.)
(s/def :document.toc/level
  string?)

;; Complete TOC entry
(s/def ::toc-entry
  (s/keys :req [:document.toc/type
                :document.toc/id
                :document.toc/title
                :document.toc/target-page
                :document.toc/target-section-id
                :document.toc/level]
          :opt [:document.toc/parent-id
                :document.toc/description]))

;; Document TOC: vector of TOC entries
(s/def :document/toc
  (s/coll-of ::toc-entry :kind vector?))

;; Document timestamps
(s/def :document/created-at
  inst?)

(s/def :document/updated-at
  inst?)

;; Document author
(s/def :document/author
  (s/nilable string?))

;; Complete RLM document
(s/def ::document
  (s/keys :req [:document/name
                :document/extension
                :document/pages
                :document/toc]
          :opt [:document/title
                :document/abstract
                :document/created-at
                :document/updated-at
                :document/author]))

;; Vector of documents
(s/def ::documents
  (s/coll-of ::document :kind vector?))

;; PDF file path input
(s/def ::pdf-path
  (s/and string?
         #(.endsWith ^String % ".pdf")))

;;; ============================================================================
;;; LLM Response Specs (for structured outputs)
;;; ============================================================================

;; Vision extraction response (node-based)
(s/def ::vision-response
  (s/keys :req [:page/nodes]))

;; TOC detection response
(s/def ::toc-detection-response
  (s/keys :req [:toc/detected]))

;; TOC has-page-numbers response
(s/def ::toc-page-index-response
  (s/keys :req [:toc/has-page-numbers]))

;;; ============================================================================
;;; Tree Building Specs (nested format - intermediate)
;;; ============================================================================

;; Nested tree node (intermediate format before flattening)
(s/def ::tree-node
  (s/keys :req [:node/id
                :node/title
                :node/start-index
                :node/end-index]
          :opt [:node/text
                :node/summary
                :node/structure
                :tree/children]))

;; Children (recursive)
(s/def :tree/children
  (s/coll-of ::tree-node :kind vector?))

;; Complete nested tree (before conversion to flat)
(s/def ::nested-tree
  ::tree-node)

;;; ============================================================================
;;; Error Specs
;;; ============================================================================

;; Error types
(s/def :error/type
  #{:encrypted
    :not-found
    :corrupted
    :llm-failure
    :parse-error
    :verification-failed
    :invalid-input})

;; Error message
(s/def :error/message
  string?)

;; Error cause (exception)
(s/def :error/cause
  any?)

;; Error data map
(s/def ::error
  (s/keys :req [:error/type]
          :opt [:error/message
                :error/cause]))

;;; ============================================================================
;;; Helper Functions
;;; ============================================================================

(defn valid-node?
  "Returns true if node is valid according to ::node spec."
  [node]
  (s/valid? ::node node))

(defn valid-flat-structure?
  "Returns true if flat structure is valid according to ::flat-structure spec."
  [structure]
  (s/valid? ::flat-structure structure))

(defn valid-document?
  "Returns true if document is valid according to ::document spec."
  [document]
  (s/valid? ::document document))

(defn valid-documents?
  "Returns true if documents vector is valid according to ::documents spec."
  [documents]
  (s/valid? ::documents documents))

(defn explain-node
  "Returns explanation of why node is invalid (or nil if valid)."
  [node]
  (when-not (valid-node? node)
    (s/explain-str ::node node)))

(defn explain-flat-structure
  "Returns explanation of why flat structure is invalid (or nil if valid)."
  [structure]
  (when-not (valid-flat-structure? structure)
    (s/explain-str ::flat-structure structure)))

(defn explain-document
  "Returns explanation of why document is invalid (or nil if valid)."
  [document]
  (when-not (valid-document? document)
    (s/explain-str ::document document)))

(defn explain-documents
  "Returns explanation of why documents vector is invalid (or nil if valid)."
  [documents]
  (when-not (valid-documents? documents)
    (s/explain-str ::documents documents)))

(defn validate-parent-refs
  "Validates that all :node/parent-id values point to existing nodes.
   
   Returns:
   - `{:valid? true}` if all parent refs are valid
   - `{:valid? false :errors [...]}` if there are orphaned nodes"
  [flat-structure]
  (let [node-ids (set (map :node/id flat-structure))
        orphans (filter (fn [node]
                          (when-let [parent-id (:node/parent-id node)]
                            (not (contains? node-ids parent-id))))
                        flat-structure)]
    (if (empty? orphans)
      {:valid? true}
      {:valid? false
       :errors (mapv (fn [node]
                       {:node/id (:node/id node)
                        :node/title (:node/title node)
                        :node/parent-id (:node/parent-id node)
                        :message "Parent node not found in structure"})
                     orphans)})))
